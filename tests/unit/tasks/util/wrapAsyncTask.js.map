{"version":3,"file":"wrapAsyncTask.js","sourceRoot":"","sources":["../../../../../tests/unit/tasks/util/wrapAsyncTask.ts"],"names":[],"mappings":"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","sourcesContent":["import * as registerSuite from 'intern!object';\nimport * as assert from 'intern/chai!assert';\nimport { stub } from 'sinon';\nimport loadModule, { cleanupModuleMocks } from '../../../_support/loadModule';\nimport { throwWithError } from '../../../_support/util';\n\nconst doneStub = stub();\nconst taskStub = stub();\nconst loggerStub = { error: stub() };\n\nlet wrapAsyncTask: any;\n\nregisterSuite({\n\tname: 'tasks/util/wrapAsyncTask',\n\n\tafterEach() {\n\t\tdoneStub.reset();\n\t\ttaskStub.reset();\n\t\tloggerStub.error.reset();\n\t},\n\n\tbefore() {\n\t\twrapAsyncTask = loadModule('tasks/util/wrapAsyncTask', {\n\t\t\t'../../src/log': { logger: loggerStub }\n\t\t});\n\t},\n\n\tafter() {\n\t\tcleanupModuleMocks();\n\t},\n\n\t'task eventually': (() => {\n\t\tfunction runWrapAsyncTaskTest(this: any, promise: Promise<any>, callback: () => void, errback?: () => void) {\n\t\t\ttaskStub.returns(promise);\n\n\t\t\tstub(this, 'async').returns(doneStub);\n\n\t\t\twrapAsyncTask(taskStub).call(this);\n\n\t\t\tthis.async.restore();\n\n\t\t\t// wrapAsyncTask performs the logic we're testing after the promise returned by the task it is\n\t\t\t// passed resolves or is rejected. So, in order to verify the results we need to test after the\n\t\t\t// promise is resolved(or rejected). By calling `then()` after wrapAsyncTask we can ensure\n\t\t\t// that the testing callbacks will be executed after the actual callbacks passed to `then` by\n\t\t\t// wrapAsyncTask.\n\t\t\treturn promise.then(callback, errback);\n\n\t\t}\n\n\t\treturn {\n\t\t\t'completes'(this: any) {\n\t\t\t\tconst taskPromise = Promise.resolve();\n\t\t\t\tconst callbackAssert = () => {\n\t\t\t\t\tassert.isTrue(loggerStub.error.notCalled);\n\t\t\t\t\tassert.isTrue(doneStub.calledWithExactly(undefined));\n\t\t\t\t};\n\n\t\t\t\treturn runWrapAsyncTaskTest.call(this, taskPromise, callbackAssert);\n\t\t\t},\n\n\t\t\t'rejects'(this: any) {\n\t\t\t\tconst taskPromise = Promise.reject(undefined);\n\t\t\t\tconst errbackAssert = () => {\n\t\t\t\t\tassert.isTrue(loggerStub.error.notCalled);\n\t\t\t\t\tassert.isTrue(doneStub.calledWithExactly(false));\n\t\t\t\t};\n\n\t\t\t\treturn runWrapAsyncTaskTest.call(\n\t\t\t\t\tthis, taskPromise, throwWithError('Should reject when task fails'), errbackAssert\n\t\t\t\t);\n\t\t\t},\n\n\t\t\t'reject; logs error messages'(this: any) {\n\t\t\t\tconst taskPromise = Promise.reject({ message: 'error message' });\n\t\t\t\tconst errbackAssert = () => {\n\t\t\t\t\tassert.isTrue(loggerStub.error.calledWith('error message'));\n\t\t\t\t\tassert.isTrue(doneStub.calledWithExactly(false));\n\t\t\t\t};\n\n\t\t\t\treturn runWrapAsyncTaskTest.call(\n\t\t\t\t\tthis, taskPromise, throwWithError('Should reject when task fails'), errbackAssert\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t})()\n});\n"]}